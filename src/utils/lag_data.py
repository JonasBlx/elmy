"""
Feature engineering helpers to build lagged datasets for time-series models.
"""

from __future__ import annotations

import argparse
from dataclasses import dataclass
from pathlib import Path
from typing import Tuple

import pandas as pd


@dataclass(frozen=True)
class LagConfig:
    """Describe how many lagged copies of the predictors must be created."""

    n_lags: int
    drop_missing: bool = True

    def __post_init__(self) -> None:
        if self.n_lags < 0:
            raise ValueError("n_lags must be a non-negative integer.")


def create_lagged_features(
    X: pd.DataFrame, y: pd.Series, n_lags: int, drop_missing: bool = True
) -> Tuple[pd.DataFrame, pd.Series]:
    """Backward-compatible wrapper around :func:`generate_lagged_dataset`."""
    config = LagConfig(n_lags=n_lags, drop_missing=drop_missing)
    return generate_lagged_dataset(X, y, config)


def generate_lagged_dataset(
    features: pd.DataFrame, target: pd.Series, config: LagConfig
) -> Tuple[pd.DataFrame, pd.Series]:
    """Create a dataframe of lagged predictors aligned with a trimmed target series.

    Args:
        features: Tabular time-indexed predictors.
        target: Target series aligned with ``features``.
        config: Lag creation parameters.

    Returns:
        A tuple of ``(lagged_features, aligned_target)`` sharing the same index.
    """
    lagged_frames = [
        features.shift(lag).add_suffix(f"_lag_{lag}") for lag in range(config.n_lags + 1)
    ]
    lagged_features = pd.concat(lagged_frames, axis=1)

    if config.drop_missing:
        lagged_features = lagged_features.dropna()
    aligned_target = target.reindex(lagged_features.index)

    return lagged_features, aligned_target


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Create lagged feature matrices from a CSV dataset."
    )
    parser.add_argument("--input", "-i", required=True, help="Path to the source CSV.")
    parser.add_argument(
        "--target-column",
        "-t",
        required=True,
        help="Column name to use as the predictive target.",
    )
    parser.add_argument(
        "--n-lags",
        "-n",
        type=int,
        default=24,
        help="Number of lagged copies to generate (exclusive of the current timestep).",
    )
    parser.add_argument(
        "--output-features",
        "-o",
        required=True,
        help="Destination CSV for the engineered features.",
    )
    parser.add_argument(
        "--output-target",
        "-y",
        required=True,
        help="Destination CSV for the aligned target series.",
    )
    parser.add_argument(
        "--keep-na",
        action="store_true",
        help="Keep rows containing NaN values generated by lagging.",
    )
    parser.add_argument(
        "--datetime-index",
        default=None,
        help="Optional column to promote to a datetime index before lagging.",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()

    input_path = Path(args.input)
    features_df = pd.read_csv(input_path)

    if args.datetime_index and args.datetime_index in features_df.columns:
        features_df = features_df.set_index(args.datetime_index)
        features_df.index = pd.to_datetime(features_df.index, utc=True, errors="coerce")
        features_df = features_df[~features_df.index.isna()]

    target_series = features_df.pop(args.target_column)

    config = LagConfig(n_lags=args.n_lags, drop_missing=not args.keep_na)
    lagged_features, aligned_target = generate_lagged_dataset(
        features_df, target_series, config
    )

    Path(args.output_features).parent.mkdir(parents=True, exist_ok=True)
    Path(args.output_target).parent.mkdir(parents=True, exist_ok=True)

    lagged_features.to_csv(args.output_features)
    aligned_target.to_csv(args.output_target, header=True)


if __name__ == "__main__":
    main()
